## 프로젝트 생성
- npx create-react-app hwanshop
    > 프로젝트 생성 시 대문자 안되는 거 주의하자
***
## Bootstrap
- `레이아웃`을 가져다 쓸 수 있는 라이브러리
    > ***복붙 최고 ㅎ_ㅎ***

### Bootstrap 설치
- 구글에 react bootstrap 검색
- `Get started` -> 쭉 따라서 설치진행하면 됨

- 터미널 - `npm install react-bootstrap bootstrap`
    > `설치 명령어`는 바뀔 수 있으니, 할 때마다  
     라이브러리 사이트에서 확인하는 게 좋다

- css 파일도 넣어주기
    - `App.js` 에서  `import 'bootstrap/dist/css/bootstrap.min.css';` 추가 혹은
    - `index.html` 의 head 태그 안에 다음 코드 추가
        ```js
            <link
                rel="stylesheet"
                href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css"
                integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65"
                crossorigin="anonymous"
            />
        ```

> 외부 라이브러리는 항상 똑같은 방식으로 설치, 사용하면 될 듯함

### Bootstrap 사용법
- 원하는 UI 검색 후 예제들을 **복붙** 하면 된다
    > UI들이 `Component` 이기 때문에 `import` 해줘야 사용 가능함
    ```js
        import { Button, Nav, Navbar } from 'react-bootstrap';
    ```
- className 따로 줘서 css로 **`커스터마이징`** 가능

***
## 이미지 넣는 법 & public 폴더 이용하기

### 리액트에서 이미지 넣는 법
- `src` 폴더에 사진넣기 -> d&d 
- src 안에 있을 경우 경로는 --> `./이미지.png`
- css에서 배경으로 사진 넣기 
    > CSS 버전 -> `background-image: url('./이미지경로');`

    > **HTML 버전**  
    **`import 작명 from '이미지경로'`**  ==> ***이게 항상 우선***  
    `style = {{ backgroundImage : 'url('+ 작명 +')' }}` 처럼 object 형식으로 넣어주면 됨  

- 이미지가 너무 커서 다 안보인다?    
    > `background-size: cover;`
- 기준점이 왼쪽이라 아직 제대로 안보일듯
    > `background-position: center;`

=> 반응형처럼 이미지 정상적으로 잘 보임!!
***
### 상품 레이아웃 3개 만들기
- `Bootstrap`으로 빠르게..
    - column 혹은 grid 를 검색해보자

- 상품 레이아웃 코드
```js
    <div className="container">
        <div className="col-md-4">
            <img src=''/>
            <h4>상품명</h4>
            <p>상품설명</p>
        </div>
        <div className="col-md-4">
            <img src=''/>
            <h4>상품명</h4>
            <p>상품설명</p>
        </div>
        <div className="col-md-4">
            <img src=''/>
            <h4>상품명</h4>
            <p>상품설명</p>
        </div>
    </div> 
```

- 외부에 호스팅해둔 이미지 =>  `img src`에 그냥 `링크(절대주소)`만 추가하면 됨!!
- `width = "80%"` 이렇게 하면 크기에 맞게 보일 듯

> 아까 `src 폴더 안 이미지` 쓰려면 `import`부터 해야된다고 했음,  
 근데 이미지가 많을 때 일일히 `import`해서 쓰긴 귀찮으니까... 이럴 때 `public` ㄱㄱ

### public 폴더도 사용가능
- public 폴더가 뭔데?
    > 리액트는 사이트 발행 전, html js css 파일을 압축함!! **(`bundling`)**

    > public 폴더에 있던 건 **압축안됨**!!

- 넣어놓고, `/이미지경로` 이런 식으로 바로 쓰면 됨

### public 사용 시 주의점
- 서버 경로...에 발행 시 문제
    > 초기 사용하던 url이 변경되면 그때그때 변경해야된다

    > 해결하려면 `{process.env.PUBLIC_URL + '/img/logo.png'}` 이런 식으로 사용하면 된다!!  
    ==> **`public 폴더의 이미지를 쓸 때 권장되는 방식`**

***

> 실제로는 `서버에서 받아온 데이터`를 뿌려주는 방식으로 진행됨!!

받아왔다치고 데이터로 진행해보자, `[ { }, { }, { } ]` 형식의 데이터

```js
    [
        {
            id : 0,
            title : "White and Black",
            content : "Born in France",
            price : 120000
        },

        {
            id : 1,
            title : "Red Knit",
            content : "Born in Seoul",
            price : 110000
        },

        {
            id : 2,
            title : "Grey Yordan",
            content : "Born in the States",
            price : 130000
        }
    ]
```

> 길고 복잡한 코드는 다른 js파일에 빼뒀다가 사용할 수 있음 ex) data.js

## import / export
- 다른 파일에 있던 자료 가져올 때 씀
- `파일 간 변수 복사(공유)`

- 변수 하나일때
    - 주는 쪽에서 `export default 변수명`
    - 받는 쪽에서 `import 사용할이름 from '내보낸경로'`
- 변수 여러 개
    - 주는 쪽에서 `export { 변수1, 변수2, ... }`
    - 받는 쪽에서 `import { 변수1, 변수2 } from '내보낸경로'`
        > 작명을 마음대로 못함!! `내보낸 이름 그대로 사용`해야 함

- `함수`, `컴포넌트`도 import / export 가능

## 길고 복잡한 state 데이터바인딩
- `object` 자료형
     ```js
        let obj = { name: "SON", age : 20 }

        let name = obj.name
        let age = obj.age
    ```

- 복잡한 자료에서 데이터 뽑을 땐 `시작기호`만 잘 보면 됨
    > `array`인지 `object` 인지!!

## 상품리스트 컴포넌트화
- 데이터바인딩
- 반복되는 부분은 map 반복문 사용

> 똑같은 기능을 하는 컴포넌트는 여러개를 만들 필요가 없음

> 살짝 다른 내용을 보여주려면 `props`를 잘 쓰면 됨

***
## 페이지 나누는 방식 
- 보통 URL 마다 페이지를 구분해주는데, ex) VIBE
    - `/detail` 로 접속하면 상세 페이지
    - `/cart` 로 접속하면 장바구니 페이지
    ***
    - `리액트 X`
        - html 파일 만들어서 상세페이지 내용 채움
        - /detail 로 접속하면 html 파일 보내줌
    - `리액트 O`
        - `index.html`만 사용함 > `SPA`
        - `컴포넌트`를 만들어서 상세페이지 내용 채움
        - /detail 로 접속하면 `기존 html`을 싹 비우고, 그 `컴포넌트` 보여줌
***
# 리액트 라우터 ☆☆☆☆☆
## react-router-dom
> `라이브러리 설치`해서 사용

### 설치방법
- 터미널 - `npm install react-router-dom@6`

### 기본셋팅
- `index.js` 로 가서, `import { BrowserRouter } from "react-router-dom";`
    - 경로에 ./ 가 없는 건 대부분 설치한 라이브러리임
- `<App />` 을 `<BrowserRouter>`로 감싸면 됨

### 사용법
- 외부 라이브러리니까 `그때그때 검색`해서 쓰면 됨
    ***
- `App.js` 에 `import { Routes, Route, Link } from 'react-router-dom'`

- `return문` 안에 이런 식으로 작성
    ```js
        <Routes>
            <Route path="/" element={ <div>메인페이지</div> } />
            <Route path="/detail" element={ <div>상세페이지</div> } />
            <Route path="/about" element={ <div>어바웃페이지</div> } />
        </Routes>
    ```

- `<Route />` 하나가 `페이지라고 생각`하면 됨
- `path` 로 URL 명시
    - `path="/"` 이렇게 하면 메인페이지
- `element` 로 보여줄 html 명시
    > 이 안에 `Component` 쓰면 될 듯

***
## 페이지 이동 버튼 만들기
- 보통 일반 사용자는 url로 접속하지 않으니까 페이지 이동 버튼이 필요할 듯
- **`<Link>` 로 페이지 이동 구현**
    - `to="/"` => 메인페이지
    - `to="/detail"` => 상세페이지
    -  etc..

## 상세페이지 컴포넌트로 만들기
- Detail 상세 페이지 만들기

## 폴더구조?
- 비슷한 파일 끼리 폴더로 묶으면 됨, 어차피 다 .js
- pages, components ...

***

## navigate 함수
- `let navigate = useNavigate();`
    - **페이지 이동**을 도와줌
        > use어쩌구 이런 애들을 `Hook(훅)` 이라 함,
            유용한 함수..
    - 그냥 `<Link>` 로 쓰면 그냥 `<a>`가 생성되는 느낌이라 별로임
    - `<Nav.Link>` 와 같은 태그에 `onClick` 추가, 안에 선언했던 `navigate()`를 넣음
    - `navigate(-1)` : 뒤로 한페이지 (뒤로가기)
    - `navigate(1)` : 앞으로 한페이지 (앞으로가기)



## 404 페이지
- 404 페이지 만들기
    - 라우터에 설정해놓지 않은 url로 접속 시 아무것도 보이지 않을 수 있음
    - 없는 페이지에요 띠워주고 싶을 때..
    - `path`에 `*` 로 명시하면 됨 (설정한 url 외 모든 것)

## nested routes
- 페이지에 딸린 하위페이지를 여러 개 보여주고 싶을 때,  
  상세 경로를 다 적어줘도 되지만 이렇게 쓸 수도 있음  
  `<Route>` 닫지말고 열어놓고 안에다 쓰기
- ```js
    <Route path="/about" element={ <About/> } >  
        <Route path="member" element={ <div>멤버들</div> } />
        <Route path="location" element={ <div>회사위치</div> } />
    </Route>
  ```
- 주의사항
    - 하위 페이지들을 상위에서 **어디에 보여줄 지** 작성해놔야함!!
    - 이때 쓰는게 `<Outlet> </Outlet>`
    - Outlet
        > nested routes 의 element 보여주는 곳

- 언제 쓸까?
    > 여러 페이지 필요할 때
    
    > 여러 유사한 페이지 필요할 때 유용함

> 모달창, 탭 같은 **동적 UI** 만들 때 `Router`를 쓰면 될 듯

- `Router` 장점
    - 뒤로가기 버튼 이용 가능
    - 페이지 이동이 쉬움 (UI 스위치 조작 쉬움)
***
## URL 파리미터
> 상세페이지가 여러개 있는데 데이터 바인딩 해야하면?
- `path="/detail/:작명/:작명2"`
    - `:작명` 처럼 작성, 얘가 **`URL 파라미터`**
    - `여러 개` 가능함
- `useParams()` 훅 사용!!
    - **`let {id} = useParams();`**
    - 얘는 문자열이니까 순번 처리할 때 주의

### array.find()
- find()는 array 뒤에 붙일 수 있으며 return 조건식, 그럼 조건식에 맞는 자료 남겨줌 
- find() 콜백함수에 파라미터 넣으면 `array자료에 있던 자료`를 뜻함
- x.id == id 라는 조건식을 써봄, 그럼 array자료.id == url에 입력한번호 일 경우 결과를 변수에 담음 
- {상품1개} 이런거 남을 듯

- `props.shoes.find((x) => x.id == id )`  
   > arrow function에서 `return과 중괄호는 동시에 생략`가능 , 동시에 안하니까 에러나더라..

***
## styled-components
- `npm install styled-components`
- 사용할 컴포넌트에 `import styled from 'styled-components'`
> JS 파일 안에서 스타일을 다 해결하고 싶을 때 사용!!

- 스타일을 입힌 **`하나의 컴포넌트를 생성하는 개념`**

- ```js
    // 컴포넌트 같은 개념이라 대문자로 작성
    let YellowBtn = styled.button`
        background : yellow;
        color : black;
        padding : 10px;
    `

    <YellowBtn>버튼</YellowBtn>
  ```
  - 이런 식으로 작성하면, `스타일 입힌 버튼`을 생성한 것
  - 스타일 작성은 `백틱` 안에다 작성

- 장점?
    - CSS 파일까지 안가도 됨
    - 스타일이 **다른 js 파일로 오염되지 않음**
        - 리액트는 스타일을 모든 곳에서 쓰기 때문에 오염될 수 있음!!
        - styled-components 안쓰고 오염 방지하려면..
            > `컴포넌트.module.css` 와 같이 작성
    - `페이지 로딩시간` 단축
        - 딱 그 페이지에만 필요한 스타일을 불러오기 때문에 단축됨

    - props 문법으로 재활용 가능
    - ```js
        let Btn = styled.button`
                background : ${ props => props.bg };
                color : black;
                padding : 10px;
            `

        <Btn bg="blue">버튼</Btn>
      ```
    - ` ${ props => props.넘긴이름 }` 처럼 사용하면 됨
        > 문자 중간에 변수같은걸 넣고 싶을 때 ${ 변수명 } 

    - 간단한 프로그래밍 가능
        - `color : ${ props => props.bg == 'blue' ? 'white' : 'black' };`
           이런 식의 코드 작성 가능
***
- 단점?
    - JS 파일이 복잡해짐,  
    컴포넌트가 `styled` 인지 아니면 `일반` 컴포넌트인지 `구분이 어려움`
    - JS 파일 간 중복 디자인이 많이 필요할때,
      다른 파일에서 스타일 넣은 것들 import 해와서 쓰면 됨  
      근데 그럼 CSS파일 쓰는거랑 차이가 없을지도
    - CSS 담당하는 디자이너가 있다면 `협업시 불편`할 수도 있음

***
# useEffect ☆☆☆☆☆
## 컴포넌트의 Lifecycle
- 페이지에 장착 `mount`
- state 변경 시 `update` (재렌더링 상황)
- 필요없으면 제거 `unmount`

> 알아야 중간중간 코드 끼워 넣을 수 있음 **`갈고리`같이 끼워넣기**

## 컴포넌트에 갈고리(hook) 다는 법
- 예전 Class 방식에서는 
    - componentDidMount() {}
    - componentDidUpdate() {}
    - componentDidUnmount() {}

- 요즘 function 방식에서는 **`useEffect`** 훅을 사용함!!
- ```js 
    import { useEffect } from "react";


    useEffect(()=>{
        // mount, update 시 여기 코드 실행됨  
        console.log('hi');
    })
  ```
- 두번 실행되는거 같은데?
    > 디버그 와 같은 이유로 `mount` 시 `원래 두 번 정도 실행 될 수 있음`
    - 저는 그것도 싫어요 하면 `<React.StrictMode>` 없애면 될 듯
    > 실제 발행 후에는 한번만 실행될 듯함

## useEffect 쓰는 이유
- useEffect 밖에다 log 찍어도 결과는 똑같음
- **그런데 왜 써?**
    - `실행 시점이 다르기 때문`
    - `useEffect` 안에 있는 코드는 **`html 렌더링 후에 동작`**
    - 위에서부터 읽을 때, html이 나중에 보여지는데, 위에 `로직이 복잡할 경우`   
    `useEffect` 안에 넣어두면 `성능상 좋을 듯`, 렌더링이 조금이라도 빨라짐
    - 컴포넌트의 핵심 기능은 html 렌더링이라,  
      그거 외의 쓸데없는 기능들은 `useEffect` 안에 적으라는 소리

## useEffect 안에 적는 코드 예시
> 어려운 연산

> 서버에서 데이터 가져오는 작업

> 타이머 장착 등등

## 왜 Effect 일까?
> `side Effect` (함수의 핵심기능과 상관없는 부가기능) 에서 유래된 듯


## useEffect 실행조건 주기
- ```js
    useEffect(() => {
        // Logic

    }, [count]) // 이러면 count라는 state가 변할 때만 실행 되는 것

    //===============================================================

    useEffect(() => {
        // Logic

    }, []) // 이러면 state가 update 될때 (재렌더링) 시에는 실행 되지 않음, mount 시만 동작
  ```
- `, []` 얘가 useEffect 의 실행조건 넣을 수 있는 곳 (`dependency` , 의존성배열 `deps`)
    > 대괄호 안에는 `여러 개의 state`를 넣을 수 있음

- `dependency`추가해도 `초기 mount 될때`는 못 막음

- `[]` 로 dependency를 주면 update 시에는 useEffect 안의 코드를 실행시키지 않음
    > 컴포넌트 mount 시 딱 1회만 실행하고 싶을 때 이렇게 사용함

## clean up function
- `useEffect 동작 전`에 실행되는 `return ()=>{}`
    ```js
        useEffect(() => {
            // Logic
            let a = setTimeout(() => {
                console.log(1);
            }, 1000);

            return () => {
                //기존 코드 치우는 거 여기에 작성
                // 초기화 같은 부분
                clearTimeout(a) //타이머 제거해 주는 함수, 변수에 담아놓으면 편하게 제거 가능
            }
        }) 
    ```
- 서버로 데이터 요청 보내는 코드를 작성해놓아서 실행중에  
  `재렌더링`이 발생한다면? ==> 버그 많아질 듯
  > return () => { //기존 데이터 요청 제거 }

- `mount` 시 실행 X, `unmount` 시 실행 O
***
## useEffect 정리
- `useEffect(()=> { })`
    > 재렌더링마다 코드 실행하고 싶으면
- `useEffect(()=> { }, [])`
    > mount시 1회 코드 실행하고 싶으면
-   ```js 
    useEffect(()=> {
        return ()=> {
            
        }
    }, [])
    ```
    > unmount시 1회 코드 실행하고 싶으면

- useEffect 실행 `전에 뭔가 실행`하려면  
 `clean up function`  
 `return () => {}`
***
> 컴포넌트가 랜더링 안에 있는 모든 함수는 (이벤트 핸들러, 이펙트, 타임아웃이나 그 안에서 호출되는 API 등) `랜더가 호출될 때 정의된 props와 state 값을 잡아둔다`, 최신이 아니라는 뜻
***